## GIL 기반 작업
GIL은 CPU bound 작업에서 성능을 저해하는 주요 매커니즘이다.

**파이썬의 GIL 제약**
- 두 개 이상의 스레드가 공유 자원을 접근할 때 발생하는 문제점 방지 위해 GIL 도입
- 한 스레드가 실행될 때 프로그램 내 자원 전체에 lock을 설정
- 동시에 멀티 스레드를 실행하더라도 GIL로 인해 한 번에 하나의 스레드만 실행된다.
- 멀티스레드의 context switching 오버헤드까지 고려하면 단일 스레드보다 성능이 떨어진다.

멀티프로세싱을 이용하여 GIL 제약을 극복할 수 있다.
다수의 프로세스를 생성하면 다수의 GIL Instance를 활용할 수 있어, 
한 번에 하나의 스레드 코드만 실행해야 하는 제약을 극복할 수 있다.
Python에서의 멀티프로세싱은 시스템 CPU들의 성능을 최대로 활용한다.

## 서브 프로세스 활용하기
파이썬에서 다수의 프로세스를 생성해 각 CPU 내의 별도 코어에서 실행시킬 수 있다.
import multiprocessing
multiprocessing.Process(target=processName)

## Process Life
multiprocessing 모듈에는 프로세스를 시작하는 세 가지 방법이 있다.
Spawn, Fork, ForkServer

### Fork를 사용해 프로세스 시작하기
Forking은 부모 프로세스가 자식 프로세스를 생성하기 위해 Unix 운영체제에서 사용하는 매커니즘이다.
자식 프로세스는 부모 프로세스의 자원을 상속받아 부모 프로세스와 거의 동일하다.
Fork 명령어는 Unix 운영체제의 표준 시스템 명령어이다.

### Spawning a process (프로세스 스폰)
별도의 프로세스를 생성함으로써 두 번째 별개의 파이썬 인터프리터 프로세스를 실행한다.
이 프로세스는 별도의 자체 GIL을 가지고 있으며 따라서 프로세스들을 병렬로 실행할 수 있다.
이로 인해 GIL의 한계를 극복할 수 있다.

새로 Spawn된 프로세스는 run 메소드로 전달된 것을 실행하는데에 필요한 자원만 상속받는다.
이 방식은 Windows 시스템에서 새로운 프로세스를 생성하고 시작할 때 사용하는 표준 매커니즘이다.
Unix 시스템에서도 사용 가능하다.

### Forkserver
별개의 다른 프로세스를 생성하는 다소 유별난 매커니즘이다.
Unix Pipe를 통해 file descriptor 전달을 지원하는 특정 Unix 플랫폼에서만 사용 가능하다.
프로그램이 프로세스를 시작하기 위해 이 매커니즘을 선택하면, 먼저 서버가 인스턴스화되어 실행된다.
이 서버는 모든 프로세스 생성 요청을 처리한다.
즉, 파이썬 프로그램이 새 프로세스를 생성하고 싶으면 서버에게 요청한다.
서버는 프로세스를 생성하며, 생성된 프로세스는 프로그램에서 자유롭게 사용할 수 있다.

### Daemon Process 
데몬 프로세스는 데몬 스레드와 거의 동일한 패턴을 답습한다.
데몬 플래그를 True로 설정해 실행 중인 프로세스를 데몬화할 수 있다.
데몬 프로세스는 메인 스레드의 프로세스가 실행되는 동안 계속 실행된다.
데몬 프로세스가 종료되는 경우는 다음과 같다.
- 스스로 실행을 완료하고 종료
- 사용자가 메인 프로그램을 강제로 중단(kill)시킬 경우 종료
데몬 프로세스에서는 자식 프로세스를 생성할 수 없다.
- 자식 프로세스를 생성할 경우 process.start()에서 오류가 발생한다.
### PID를 사용하여 프로세스 식별하기
운영체제 내 모든 프로세스는 프로세스 식별자를 가지는데 보통 PID라고 한다.
멀티프로세스 파이썬 프로그램에서 서브프로세스가 생성되면 새로운 PID를 배정받아 구별한다.
print(multiprocessing.current_process().pid)

### 프로세스 종료하기
작은 파이썬 코드에서는 프로세스를 종료하지 않아도 큰 문제를 유발하지는 않으나 대규모 기업용 파이썬 프로그램에서는 더 이상 필요하지 않은 프로세스를 종료하는 것이 대단히 중요하다.
myProcess.terminate()

### multiprocessing.Process의 서브클래스 정의
multiprocessing.Process 의 서브클래스를 정의하여 프로세스를 생성한다.
class MyProcess(multiprocessing.Process):
...

## Multiprocessing Pool (멀티프로세싱 풀)
Pool 클래스는 프로그램 내의 다수의 프로세스의 생성과 실행, 시작을 간결하고 빠르게 해준다.
concurrent.futures.ProcessPoolExecutor와 multiprocessing.Pool의 차이점
- 둘 다 프로세스 풀을 구현한다.
- 프로세스 풀의 multiprocessing.Pool 구현은 병렬 처리 기능을 제공하기 위해 거의 동일한 구현 방식을 사용한다.
- ProcessPoolExecutor와 다른 형태의 프로세스 풀 구현이 필요한가?
- concurrent.futures 모듈은 더 단순하다. 그러나, 프로세스의 미세한 제어가 쉽지 않다.
- multiprocessing 모듈이 더 낮은 버전의 파이썬에서 동작하므로 호환성이 높다.
- 하지만 보통의 상황에서는 concurrent.futures 모듈 사용을 권장한다.

## 컨텍스트 관리자와 프로세스 풀
with Pool(4) as myPool:
코드가 간단하며, Pool 객체를 명시적으로 release할 필요가 없다.
인자 중 maxtasksperchild는 쓰지 않는 자원을 반납하는 효과가 있다.

